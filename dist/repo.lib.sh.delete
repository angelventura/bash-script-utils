#!/bin/bash
#
# $HeadURL: http://svn/svn/estrada-gconf/scripts/utils/utils.sh $
# $Id: utils.sh 30 2009-07-14 13:38:57Z ventura $
#
# Utilidades para el repositorio de ficheros originales
# Los fichero originales estan en el directorio REPO.
#  Para cada fichero hay un directorio con el nombre del fichero, que contiene
#		- El original
#		- Un fichero txt con los datos metadatos del fichero.
#		- Un fichero info con la informacion de ffprobe
#		- Un directorio transcoder.
#				- Este directorio contiene un fichero host, para cada uno de los transcoders a los que se ha enviado. ATENCION, la existencia de este archivo es la qui indica que el envio se ha realizado correctamente.
#				

loadLibrary ffmpeg_lib;
loadLibrary transcoder_lib;
loadLibrary server_lib;

# Directorio donde se guarda a los transcoders a los que se ha enviado.
REPO_TRANSCODER_DIR=transcoder


# la extension con la informacion adicional para los videos.
DESC_EXT=.txt
URL_EXT=.url

# default content for the empty desc files
EMPTY_TXT_FILE_CONTENT="# Empty file, autogenerated\n\
name=\n\
description=\n\
tags=\n\
sizeHuman=\n\
thumbnailTime=60\n\
duration=\n";

# echo the path of the server name
function repo.file.dir(){
	local file=$(file.basename "$1");
#	local file="$1";
	
	echo $REPO_DIR/"$file";
}

# echo the path of the server name
function repo.file.path(){
	local file=$(file.basename "$1");
#	local file="$1";

	echo $REPO_DIR/"$file"/"$file";
}

# echo the path of the server name
function repo.file.thumbnailTime(){
	local file="$1";
	
	
}


# Returns de size of the file in bytes
function repo.file.size(){
	local file="$1";

	echo $(file.size $(repo.file.path "$file"));
}

# Returns de size of the file in bytes
function repo.file.size.human(){
	local file="$1";

	echo $(file.size.human $(repo.file.path "$file"));
}

# Indica si el file existe en el repositorio.
function repo.file.exists(){
	local file="$1";

#	log.debug ---------------------exists: \"$file\";

	if [ -d $(repo.file.dir "$file") ] ; then
#		-a file True if file exists.
#		-e file True if file exists.
# File may be a symbolick file		
		if [ -f $(repo.file.path "$file") ] ||  [ -h $(repo.file.path "$file") ] ; then
			return $EXIT_STATE_OK;
		else
			log.error ++++++++++++++ NO EXISTE  $(repo.file.path "$file")
			return $FALSE;
		fi
	else
		return $FALSE;
	fi
}

# This creates a file in repo from the file passed in arg
function repo.file.create(){
	local filepath="$1";
	local file=$(file.basename "$filepath");

	if repo.file.exists "$file" ; then 
		log.warn Ya existe el fichero \"$file\" en le repositorio.
	else
		local path=$(repo.file.dir "$file");

		batch.exec mkdir "$path";

		path=$(repo.file.path "$file");

		# Vemos si los movemos o creamos el enlace simbolico.

		if file.isInSubtree $INCOM_DIR $file ; then
			batch.exec mv $filepath $path; 
		elif file.isInSubtree $ROOT_DIR $file ; then
			log.warn File \"$file\" is in working dir but not into the income dir, avoiding ...
		else
			# Esta fuera, enlace simbolico
			local sourcepath=`pwd`;
			local source=$sourcepath/$filepath;

			log.warn File \"$file\" is outof the working dir. making a simbolic link...
			log.info.out File \"$file\" is outof the working dir. making a simbolic link... $source, $path;
			batch.exec ln -s $source $path; 
			echo ln -s $source $path; 
#			echo `pwd`;
		fi
	fi	
}

function repo.file.remove(){
	local file="$1";

	if repo.file.exists $file ; then 
		batch.exec rm -rf $(repo.file.dir $file);
	fi
}


# The path for the ffbprobe information file
function repo.file.info.path(){
	local file="$1";

	echo $REPO_DIR/$file/$file$FFPROBE_EXT;
}

# indicates whether the file information exists
function repo.file.info.exists(){
	local file="$1";

	if [ -f $(repo.file.info.path $file) ] ; then
		return $EXIT_STATE_OK;
	else
		return $FALSE;
	fi;
}

# Removes the video file nformation
function repo.file.info.remove(){
	local file="$1";

	if repo.file.info.exists $file ; then
		batch.exec rm $(repo.file.info.path $file);
	fi;
}

# creates the video file information, if an old one exits
# it removes it.
function repo.file.info.create(){
#	local file="$1";
	local file=$(file.basename $1);
	local filePath=$(repo.file.path $file);
	local infoPath=$(repo.file.info.path $file);

	repo.file.info.remove $file;

#	batch.exec $FFPROBE_CMD -v quiet -print_format flat -show_format -show_streams $filePath > $infoPath;

	ff.info.create $filePath $infoPath;
}



#
# File DEsc
#


# The path for the ffbprobe information file
function repo.file.desc.path(){
	local file="$1";

	echo $REPO_DIR/$file/$file$DESC_EXT;
}

# The path for the ffbprobe information file
function repo.file.desc.filename(){
	local file="$1";

	echo $file$DESC_EXT;
}

# The path for the ffbprobe information file
function repo.file.desc.url.filename(){
	local file="$1";

	echo $file$DESC_EXT$URL_EXT;
}

# indicates whether the file information exists
function repo.file.desc.exists(){
	local file="$1";

	if [ -f $(repo.file.desc.path $file) ] ; then
		return $EXIT_STATE_OK;
	else
		return $FALSE;
	fi;
}

# Removes the video file nformation
function repo.file.desc.remove(){
	local file="$1";

	if repo.file.desc.exists $file ; then
		batch.exec rm $(repo.file.desc.path $file);
	fi;
}

# creates the video file information, if an old one exits
# it removes it.
function repo.file.desc.createormove(){
	local filepath="$1";
	local file=$(file.basename "$filepath");
	local descPath=$(repo.file.desc.path "$file");


	if [ -f "$filepath$DESC_EXT" ] ; then 
		log.debug Moving desc file from  $filepath$DESC_EXT to $descPath.;
		batch.exec mv "$filepath$DESC_EXT" "$descPath"; 
	else
		# creamos l informacion por defecto.
		log.debug Creating default desc file info path: $descPath.;

#		echo -e "$EMPTY_TXT_FILE_CONTENT" > "$descPath";

		echo "# Empty file, autogenerated" > "$descPath";
		local description="$(repo.file.generate.description $file)"
		echo "name=\"$description\"" >> "$descPath";
		echo "description=\"$description\"" >> "$descPath";
		echo "tags=\"$description\"" >> "$descPath";

		echo "sizeHuman=$(file.size.human $videoFile)" >> "$descPath";

		echo "thumbnailTime=60" >> "$descPath";

		local videoFilePath=$(repo.file.path "$file");
		echo "duration=$(ff.video.duration $videoFilePath)" >> "$descPath";

	fi
	
}



#
# transcoders
#


# tranascoder sent path
function repo.file.transcoder.path(){
	local file="$1";
	local transcoder="$2";

	echo $REPO_DIR/$file/$REPO_TRANSCODER_DIR/$(server.file.name $transcoder);
}

# tranascoder sent path
function repo.file.transcoder.dir(){
	local file="$1";

	echo $REPO_DIR/$file/$REPO_TRANSCODER_DIR;
}

# Indica si el original ya se le ha enviado al transcoder.
function repo.file.transcoder.create(){
	local file="$1";
	local transcoder="$2";

	local dirPath=$(repo.file.transcoder.dir $file);

	if [ ! -d $dirPath ] ; then
		if ! batch.exec mkdir $dirPath ; then
			log.exception Creando el directorio $dirPath;
			return $FALSE;
		fi
	fi
	
	if  batch.exec cp $(server.file.path $transcoder) $(repo.file.transcoder.path $file $transcoder) ; then
		return $TRUE;
	else
		log.exception Marking the file $file as sended to transcoder $transcoder;
		return $FALSE;
	fi
}

# Indica si el original ya se le ha enviado al transcoder.
function repo.file.transcoder.getSend(){
	local file="$1";
	local path=$(repo.file.transcoder.dir "$file");

	if [ -d "$path" ] ; then
		echo `ls $path`;
	else
		echo "";
	fi
}

# Indica si el original ya se le ha enviado al transcoder.
function repo.file.transcoder.exists(){
	local file="$1";
	local transcoder="$2";

	if [ -d $(repo.file.transcoder.dir $file) ] ; then
		if [ -f $(repo.file.transcoder.path $file $transcoder) ] ; then
			return $EXIT_STATE_OK;
		else
			return $FALSE;
		fi
	else
		return $FALSE;
	fi
}

# Indica si el original ya se le ha enviado al transcoder.
function repo.file.transcoder.send(){
	local file="$1";
	local transcoder="$2";
#	local playListName="$3";
#	local profile=$(playlist.data.profile $playListName);

#	log.debug $transcoder $LocalHost;

	if server.isLocalhost "$transcoder" ; then 
		# Si el local host es el transcoder solo se maraca como enviado pero no se envia
		repo.file.transcoder.create $file $transcoder;

		log.info File \"$file\" added to localhost transcoder \"$transcoder\";

		# creamos localmente la inforacion de transcodificacion, para el profil 
		# de la playlist ....
#		transcoder.trancode.prepare $file $profile;

		log.info Local File \"$file\" mark as sended to local server:\"$transcoder\";

		return $TRUE;
	else
		local code;
		local message;
		local size=$(repo.file.size $file );
		local command="existsFileInrepo.sh $file $size";

		# Verificamos que el fichero no existe ya en remoto.
		message=$(server.execute.remote.script $transcoder "$command");
		code=$?;

#		255 no hay conexion
#		127 no hay comando

		if error.isOk $code ; then 
			# Existe en remoto a si que lo marcamos como enviado
			log.debug File already exists $file in server $transcoder;
				
			# 4/ creo la informacion para la trasncodificarlo ... remotamente ....
			# no por que se supone que ya esta ...
			# No importa la machacamos ....
#			command="createTranscoderInfo.sh -p $profile $file";
#			message=$(server.execute.remote.script $transcoder "$command");
#			code=$?;
#
#			if error.isOk $code ; then
#				log.debug Creado la transcodificacion remota:$message;
#				
#				repo.file.transcoder.create $file $transcoder;
#			else
#				log.error Error creating remote transcoding info for file:$file on server:$transcoder;
#			fi

			repo.file.transcoder.create $file $transcoder;
			return $TRUE;
		else 
			if [ $code == 1 ]; then
				# No existe en el repositorio remoto lo enviamos
				
				# Si no existe lo enviamos el fichero
				local sshAccess=$(server.data.sshAccess $transcoder);
				local repo=$(server.data.instalationRoot $transcoder);

				# 1/ borro la informacion de repo.file.transcoder.create 
				#  No es necesario borrarla por que se sobre escrive?

				# 2/ Copio la estructura de directorios de forma recursiva.
				batch.exec scp -r $(repo.file.dir $file) $sshAccess:$repo/repo
				code=$?;
				if error.isError $code ; then
					log.error Error copiando al repositorio de destino ..
					return $FALSE;					
				else
					repo.file.transcoder.create $file $transcoder;
					return $TRUE;
				fi

				# 4/ Se crea remotamente la informacion para transcodificarlo
				# Para ello se necesita el profile de transcodificacion de la play list
				# y la play list para saber donde se alberga la misma y poder enviarlo.
				# y la play list tambien hay que crearla ....
#				command="createTranscoderInfo.sh -p $profile $file";
#				message=$(server.execute.remote.script $transcoder "$command");
#				code=$?;
#
#				if error.isOk $code ; then
#					log.debug Creado la transcodificacion remota:$message;
#					# 3/ Creo la informacion de transcoder en el repositorio que indica 
#				    #   que ese fichero ya se ha enviado a dicho transcoder.
#
#					repo.file.transcoder.create $file $transcoder;
#				else
#					log.error Error creating remote transcoding info for file:$file on server:$transcoder;
#				fi
			else
				# Es un codigo de error distinto de uno por lo que hay error de conexion 
				# o de comando ...
				log.error Error accesing to server:\"$transcoder\" while sending file \"$file\". Error: \"$code\".
				return $FALSE;
			fi
		fi
	fi
}
# .... FIN ...

# 		# verificamos si se pudo ejecutar el comando
# 		if error.code.exists $ret ; then
# 			if error.isError $ret ; then 
# 				# Si no existe lo enviamos el fichero
# 				local sshAccess=$(server.data.sshAccess $transcoder);
# 				local repo=$(server.data.instalationRoot $transcoder);
				
# 				# 1/ borro la informacion de repo.file.transcoder.create 
# 				#  No es necesario borrarla por que se sobre escrive?

# 				# 2/ Copio la estructura de directorios de forma recursiva.
# 				batch.exec scp -r $(repo.file.dir $file) $sshAccess:$repo/repo
				
# 				# 4/ Se crea remotamente la informacion para transcodificarlo
# 				# Para ello se necesita el profile de transcodificacion de la play list
# 				# y la play list para saber donde se alberga la misma y poder enviarlo.
# 				# y la play list tambien hay que crearla ....
# 				command="createTranscoderInfo.sh -p $profile $file";
# 				ret=$(server.execute.remote.script $transcoder "$command");

# 				... aqui ver que devuelve en funcion de los errores ...
# 				el stderr se truan cuando se escribe en el ....
# 				En el fichero de ejecucion de la transcodificacion incluir los comados locales ... poner la definiciones ....



# 				if error.code.exists $ret ; then

# 				    # 3/ Creo la informacion de transcoder en el repositorio que indica 
# 				    #   que ese fichero ya se ha enviado a dicho transcoder.
# 					repo.file.transcoder.create $file $transcoder;
# 				else
# 					log.error Error creating transcoding info for file:$file on server:$transcoder;					
# 				fi
				
# 				log.info File \"$file\" sent to server \"$transcoder\";
# 			else
# 				# Existe en remoto a si que lo marcamos como enviado
# 				log.debug File already exists $file in server $transcoder;
				
# 				# 4/ creo la informacion para la trasncodificarlo ... remotamente ....
# 				# no por que se supone que ya esta ...
# 				# No importa la machacamos ....
# 				command="createTranscoderInfo.sh -p $profile $file";
# 				ret=$(server.execute.remote.script $transcoder "$command");

# 				if error.code.exists $ret ; then
# 					log.debug RET:$ret;

# 					repo.file.transcoder.create $file $transcoder;
# 				else
# 					log.error Error creating transcoding info for file:$file on server:$transcoder;
# 				fi

# 			fi			
# 		else
# 			log.error Error accesing to server:\"$transcoder\" while sending file \"$file\". Error: \"$ret\".
# 			return $FALSE;

# 		fi
# 	fi
#	echo $ret;
# }



function repo.import.file(){
	local file="$1";
	local localPlayList="$2";
	local transcoder="$3";
	local filename=$(file.basename "$file");

	if [[ "$file" == "*~" ]] ; then
		log.error Ignoring file:\"$file\". Moviendolo a la carpeta de error.;
		batch.exec mv "$file" $ERROR_DIR;
		return $FALSE;
	elif [[ "$file" == *.txt ]] ; then
		log.info Ignorando el fichero: \"$file\"
		return $FALSE;
	else
		log.info Tratando el Fichero: \"$file\"
		
		if ! repo.import.validate.videofile "$file" ; then 
			log.error El fichero \"$file\" no es valido.;
#			log.error El fichero \"$file\" no es valido. Moviendolo a la carpeta de error.;
 			# batch.exec mv $file $ERROR_DIR;
			return $FALSE;
		elif repo.file.exists "$filename" ; then
  			# Ya exixte el repositorio que hacemos?
  			log.warn Ya existe el fichero \"$file\" en el repositorio.
			return $FALSE;
		else
			log.warn ---- Tratando el fichero \"$file\"
			
			# creamos el directorio y movemos el fichero.
			repo.file.create "$file";

			# creamos la informacion
			repo.file.info.create "$file";

			# Creamos os movemos los ficheros de informacion
			repo.file.desc.createormove "$file";
						
  			if [ "$localPlayList" == "" ] ; then 
				# buscamos la playlist por defecto
				if playlist.default.exists ; then 
  					playlist.file.create $(playlist.default) "$filename" $transcoder;
				fi
  			else
  				playlist.file.create $localPlayList "$filename" $transcoder;
  			fi
			return $EXIT_STATE_OK;
		fi
	fi
}


# Importa a file getting the parametres from array
function repo.import.file.array(){
    declare -a array=("${!1}");
 	local file="$2";
 	local localPlayList="${array[0]}";
	local transcoder="${array[1]}";


	if [ -d "$file" ] ; then 
#		log.debug "$file" is a directory ignoring ...
		return 
	fi
#	local localPlayList="$1";
#	local transcoder="$2";
#	local file="$3";


	#log.info $*;
	#log.info File: \"$file\" \"$localPlayList\" \"$transcoder\";



	if repo.import.file  "$file" "$localPlayList" "$transcoder" ; then 
		log.info.out Imported file \"$file\".
	else
		log.info.out NOT IMPORTED file \"$file\".
	fi
}

	

# Indica si el original ya se le ha enviado al transcoder.
function repo.import.incomdir(){
	local localPlayList="$1";
	local transcoder="$2";
	local array=("$1" "$2");

	# First eleiminate white spaces from files name
	file.dir.changeFileWihiteEspaces "$INCOM_DIR"

	file.dir.iterate "$INCOM_DIR" "repo.import.file.array array[@]";	
#	file.dir.iterate "$INCOM_DIR" "repo.import.file.array '$1' '$2'";	
}


# This validate if the file is a right video file
function repo.import.validate.videofile(){
	local file="$1";	

	log.info Verificando el fichero: \"$file\";

    if ff.video.verify "$file" ; then
		return $EXIT_STATE_OK;
	else
		return $FALSE;
	fi


# 	$FFMPEG_CMD -v error -i "$file" -f null - > $LOG_ERROR_FILE 2> /dev/null;

#     if [ $? -ne 0 ] ; then
# 		return $FALSE;
# 	else
# 		return $EXIT_STATE_OK;
# 	fi
}



# Axuiliary function to iterate over REPO FILES
function repo.inner.iterator(){
	local function="$1";
	local file="${@:${#@}}";
	
	# To call the client function use the arguments received remoing: 
	# Deletes the first argument that is the $function
	# And the last one is replaced by playlist.name
	
	$function ${@:2:$#-2} $file;
}


function repo.iterate(){
	local function="$1";

	file.dir.iterate $REPO_DIR "repo.inner.iterator $function";
}



#
# REPOFILE PROPERTIES
#

#_REPOFILE_NAME="_repofileName";
#_REPOFILE_FIELD_NAMES=$_REPOFILE_NAME;
#_REPOFILE_FIELD_NAMES=$_REPOFILE_FIELD_NAMES:"name";
#_REPOFILE_FIELD_NAMES=$_REPOFILE_FIELD_NAMES:"description";
#_REPOFILE_FIELD_NAMES=$_REPOFILE_FIELD_NAMES:"tags";
#_REPOFILE_FIELD_NAMES=$_REPOFILE_FIELD_NAMES:"sizeHuman";
#_REPOFILE_FIELD_NAMES=$_REPOFILE_FIELD_NAMES:"thumbnailTime";
#_REPOFILE_FIELD_NAMES=$_REPOFILE_FIELD_NAMES:"duration";

#IFS=: read -a _REPOFILE_FIELD_NAMES_ARRAY <<< "$_REPOFILE_FIELD_NAMES"


#declare -g -A _REPOFILES_HASH_TABLE;

# Rweturns if the server data has been loaded.
# function repo.loaded(){
# 	local file="$1";

# 	if [ "$(repo.data $file $_REPOFILE_NAME)" == "" ] ; then
# 		return $FALSE;
# 	else
# 		return $EXIT_STATE_OK;
# 	fi
# }

# returns the value of one filed of the server data
# function repo.data.load(){
# 	local file="$1";
# 	local field="$2";
# 	local value="$3";

# 	local fieldName="$file"_"$field";

# 	_REPOFILES_HASH_TABLE[$fieldName]=$value;	
# }


#
# loads intoe the current shell the variebles of the server
# function repo.load(){
# 	local file="$1";
	
# 	if repo.file.exists $file ; then
# 		if repo.loaded $file ; then
# 			return $EXIT_STATE_OK;		
# 		else
# 			local filePath=$(repo.file.desc.path $file);
			
# 			# Borramos los valores antes de cargar
# 			for v in "${_REPOFILE_FIELD_NAMES_ARRAY[@]}" ; do
# 				declare $v="";
# 			done;

# 			. $filePath;
			
# 			for v in "${_REPOFILE_FIELD_NAMES_ARRAY[@]}" ; do
# 				repo.data.load "$file" "$v" ${!v};
# 			done;

# 			repo.data.load "$file" "$_REPOFILE_NAME" $file;

# 			return $EXIT_STATE_OK;		
# 		fi
# 	else
# 		log.error Error loading file \"$file\";
# 		return $FALSE;
# 	fi
# }


# returns the value of one filed of the server data
# function repo.data(){
# 	local file="$1";
# 	local field="$2";

# 	local fieldName="$file"_"$field";

# 	echo ${_REPOFILE_FIELD_NAMES["$fieldName"]};	

# 	return $TRUE;
#}

#
# loads intoe the current shell the variebles of the server
function repo.load(){
	local file="$1";
	
	if repo.file.exists $file ; then
		local filePath=$(repo.file.desc.path $file);
					
		. $filePath;
		
		
		return $EXIT_STATE_OK;		
	else
		log.error Error loading file \"$file\";
		return $FALSE;
	fi
}


function repo.data.thumbnailTime(){
	local file="$1";

	repo.load $file;

	echo $thumbnailTime;
	
	return $TRUE;
}

function repo.file.generate.description(){
	local file="$1";	
	local replcedName="$(file.name $file)";

	replcedName=${replcedName//\'/ };
	replcedName=${replcedName//./ };
	replcedName=${replcedName//-/ };
	replcedName=${replcedName//_/ };
	replcedName=${replcedName//\[/ };
	replcedName=${replcedName//\]/ };

	replcedName=${replcedName//\(/ };
	replcedName=${replcedName//\)/ };
	replcedName=${replcedName//\&/ };

	echo $replcedName;
}
